#!/usr/bin/env npx tsx
/**
 * fetch-investigation.ts â€” Fetches the AI investigation and full comment
 * history from a Linear ticket.
 *
 * Used by the autofix GitHub Actions workflow to get context before
 * running Claude Code. Outputs the investigation markdown to stdout,
 * including human comments as supplemental context and previous audit
 * logs for retry awareness.
 *
 * Usage:
 *   LINEAR_API_KEY=... npx tsx scripts/fetch-investigation.ts AGT-7
 */

import { LinearClient } from '@linear/sdk'

/** Check if a comment was generated by the autonomous pipeline. */
function isMachineComment(body: string): boolean {
  return body.includes('<!-- MACHINE:')
}

/** Extract the machine marker type from a comment (e.g., "investigation", "audit", "question"). */
function getMachineType(body: string): string | null {
  const match = body.match(/<!-- MACHINE:(\w+)/)
  return match ? match[1] : null
}

async function main() {
  const identifier = process.argv[2]
  if (!identifier) {
    console.error('Usage: npx tsx scripts/fetch-investigation.ts <identifier>')
    process.exit(1)
  }

  if (!process.env.LINEAR_API_KEY) {
    console.error('LINEAR_API_KEY not set')
    process.exit(1)
  }

  const client = new LinearClient({ apiKey: process.env.LINEAR_API_KEY })

  // Look up issue by identifier using search, then fetch full issue
  const results = await client.searchIssues(identifier)
  const searchHit = results.nodes.find(i => i.identifier === identifier)
  if (!searchHit) {
    console.error(`Issue ${identifier} not found`)
    process.exit(1)
  }

  const issue = await client.issue(searchHit.id)

  // Get the issue description
  const parts: string[] = []
  parts.push(`## Ticket: ${identifier}`)
  parts.push(`**Title:** ${issue.title}`)
  parts.push('')
  if (issue.description) {
    parts.push('## Description')
    parts.push(issue.description)
    parts.push('')
  }

  // Get ALL comments, sorted chronologically
  const comments = await issue.comments()
  const allComments = comments.nodes.sort((a, b) => {
    const aTime = a.createdAt ? new Date(a.createdAt).getTime() : 0
    const bTime = b.createdAt ? new Date(b.createdAt).getTime() : 0
    return aTime - bTime
  })

  // Separate machine vs human comments
  const investigation = allComments.find(c => getMachineType(c.body) === 'investigation')
  const humanComments = allComments.filter(c => !isMachineComment(c.body))
  const audits = allComments.filter(c => getMachineType(c.body) === 'audit')
  const questions = allComments.filter(c => getMachineType(c.body) === 'question')

  // AI Investigation
  if (investigation) {
    parts.push('## AI Investigation Comment')
    parts.push(investigation.body)
  } else {
    parts.push('## No AI Investigation Found')
    parts.push('No investigation comment was found. Analyze the ticket description directly.')
  }

  // Human comments as supplemental context
  if (humanComments.length > 0) {
    parts.push('')
    parts.push('## Human Context (supplemental)')
    parts.push('_These are comments from humans that may provide additional context or answers to questions._')
    parts.push('')
    for (const c of humanComments) {
      const ts = c.createdAt ? new Date(c.createdAt).toISOString() : 'unknown'
      parts.push(`**Comment (${ts}):**`)
      parts.push(c.body)
      parts.push('')
    }
  }

  // Previous audit logs (shows what was already tried)
  if (audits.length > 0) {
    parts.push('')
    parts.push('## Previous Attempts')
    parts.push('_These are logs from previous autofix runs. Learn from what was tried._')
    parts.push('')
    for (const c of audits) {
      parts.push(c.body)
      parts.push('')
    }
  }

  // Previous questions (shows what the system was stuck on)
  if (questions.length > 0) {
    parts.push('')
    parts.push('## Previous Questions')
    for (const c of questions) {
      parts.push(c.body)
      parts.push('')
    }
  }

  // Output to stdout for the workflow to capture
  console.log(parts.join('\n'))
}

main().catch(err => {
  console.error('Error:', err.message || err)
  process.exit(1)
})
